datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch"]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  // Do not change the `id` field, it must be permanent and immutable.
  id                          String         @id @default(cuid())
  // The `username` can be updated anytime by the user.
  // It will acquire the `id` as its default value.
  username                    String?        @unique
  email                       String?        @unique
  name                        String?
  gender                      String?
  birthDate                   DateTime?
  phoneNumber                 String?        @unique
  address                     String?
  bio                         String?
  website                     String?
  relationshipStatus          String?
  emailVerified               DateTime?
  image                       String?
  accounts                    Account[]
  sessions                    Session[]
  profilePhoto                String?
  coverPhoto                  String?
  post                        Post[]
  visualMedia                 VisualMedia[]
  postLikes                   PostLike[]
  comments                    Comment[]
  commentLikes                CommentLike[]
  followers                   Follow[]       @relation("following")
  following                   Follow[]       @relation("follower")
  activities                  Activity[]     @relation("activity")
  notifications               Activity[]     @relation("notification")
  passwordHash                String? // For phone+password authentication
  conversationsAsParticipant1 Conversation[] @relation("ConversationParticipant1")
  conversationsAsParticipant2 Conversation[] @relation("ConversationParticipant2")
  messages                    Message[]

  // Wallet fields
  walletAddress        String?             @unique
  apeBalance           Float               @default(0)
  walletCreatedAt      DateTime?
  sentTransactions     WalletTransaction[] @relation("sender")
  receivedTransactions WalletTransaction[] @relation("receiver")

  // TTS fields for featured users
  featured     Boolean @default(false)
  ttsModelId   String?
  ttsVoiceId   String?
  
  // Punked member status - members with custom voices who can override public voices
  punked       Boolean @default(false)

  // Pospal balance caching fields
  appessoBalance          Float?    // Cached Appesso balance
  appessoBalanceUpdatedAt DateTime? // When the balance was last fetched from Pospal

  // AI Profile relation
  aiProfile               AIProfile?
  aiMemories              AIMemory[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Follow {
  id          Int    @id @default(autoincrement())
  follower    User   @relation("follower", fields: [followerId], references: [id], onDelete: Cascade)
  followerId  String
  following   User   @relation("following", fields: [followingId], references: [id], onDelete: Cascade)
  followingId String

  @@unique([followerId, followingId])
}

model Post {
  id           Int           @id @default(autoincrement())
  content      String?
  createdAt    DateTime      @default(now())
  visualMedia  VisualMedia[]
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String
  postLikes    PostLike[]
  comments     Comment[]
  isTask       Boolean       @default(false)
  rewardAmount Float         @default(0)
  taskStatus   String? // OPEN, IN_PROGRESS, COMPLETION_REQUESTED, COMPLETED, REJECTED
  completedBy  String? // UserId who accepted the task
  completedAt  DateTime? // When task was accepted

  // Commission payment tracking
  initialPaymentAmount  Float? // 50% paid on acceptance
  initialPaymentAt      DateTime? // When initial payment was made
  finalPaymentAmount    Float? // Remaining 50%
  finalPaymentAt        DateTime? // When final payment was made
  completionRequestedAt DateTime? // When acceptor requested completion
  completionConfirmedAt DateTime? // When owner confirmed completion

  // TTS audio field
  audioUrl String?
}

model PostLike {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    Int

  @@unique([userId, postId])
}

model Comment {
  id           Int           @id @default(autoincrement())
  content      String
  createdAt    DateTime      @default(now())
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String
  commentLikes CommentLike[]

  // If there is a `postId`, it is a comment
  post   Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId Int

  // If there is a `parentId`, it is a reply
  parent   Comment? @relation("Replies", fields: [parentId], references: [id], onDelete: Cascade)
  parentId Int?

  // Self-referential relation
  replies Comment[] @relation("Replies")
}

model CommentLike {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId Int

  @@unique([userId, commentId])
}

model VisualMedia {
  id         Int      @id @default(autoincrement())
  type       String   @default("PHOTO")
  fileName   String
  uploadedAt DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  post       Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId     Int
}

// This Activity model is similar to this approach: https://stackoverflow.com/a/1766371/8434369
// Example:
// * If the activity type is 'CREATE_COMMENT', the `sourceId` must be the `id` of the Comment and
// its `targetId` must be the `id` of the Post that was commented on.
//
// * If the activity type is 'POST_LIKE', the `sourceId` must be the `id` of the PostLike and
// its `targetId` must be the `id` of the liked Post.
//
// * If the activity type is 'COMMENT_MENTION', the `sourceId` must be the `id` of the Comment and
// its `targetId` must be the `id` of the Post that was commented on.
model Activity {
  id                   Int      @id @default(autoincrement())
  createdAt            DateTime @default(now())
  type                 String
  sourceId             Int
  targetId             Int?
  sourceUser           User     @relation("activity", fields: [sourceUserId], references: [id], onDelete: Cascade)
  sourceUserId         String
  targetUser           User     @relation("notification", fields: [targetUserId], references: [id], onDelete: Cascade)
  targetUserId         String
  isNotificationActive Boolean  @default(true)
  isNotificationRead   Boolean  @default(false)
}

model ActivityType {
  id   Int    @id @default(autoincrement())
  name String @unique
}

model VisualMediaType {
  id   Int    @id @default(autoincrement())
  name String @unique
}

model Gender {
  id   Int    @id @default(autoincrement())
  name String @unique
}

model RelationshipStatus {
  id   Int    @id @default(autoincrement())
  name String @unique
}

model Conversation {
  id             String    @id // Format: userId1_userId2 (sorted)
  participant1   User      @relation("ConversationParticipant1", fields: [participant1Id], references: [id], onDelete: Cascade)
  participant1Id String
  participant2   User      @relation("ConversationParticipant2", fields: [participant2Id], references: [id], onDelete: Cascade)
  participant2Id String
  messages       Message[]
  createdAt      DateTime  @default(now())
  lastMessageAt  DateTime  @default(now())

  @@unique([participant1Id, participant2Id])
  @@index([lastMessageAt])
}

model Message {
  id             String       @id @default(cuid())
  content        String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  conversationId String
  sender         User         @relation(fields: [senderId], references: [id], onDelete: Cascade)
  senderId       String
  createdAt      DateTime     @default(now())
  isRead         Boolean      @default(false)

  // Red packet fields
  type               String    @default("TEXT") // TEXT, RED_PACKET, SYSTEM, TASK_COMPLETION_REQUEST
  redPacketAmount    Float?
  redPacketMessage   String?
  redPacketStatus    String? // PENDING, CLAIMED
  redPacketClaimedAt DateTime?

  // Task completion fields
  taskPostId           Int?
  taskFinalAmount      Float?
  taskCompletionStatus String? // pending, completed, rejected, failed

  // AI response field
  isAIResponse         Boolean  @default(false)

  @@index([conversationId, createdAt])
  @@index([senderId])
  @@index([type])
}

model WalletTransaction {
  id          String  @id @default(cuid())
  type        String // DEPOSIT, WITHDRAW, TRANSFER, REWARD
  amount      Float
  status      String  @default("PENDING") // PENDING, COMPLETED, FAILED
  description String?

  fromUser   User?   @relation("sender", fields: [fromUserId], references: [id], onDelete: SetNull)
  fromUserId String?

  toUser   User?   @relation("receiver", fields: [toUserId], references: [id], onDelete: SetNull)
  toUserId String?

  txHash      String?   @unique // Blockchain transaction hash
  createdAt   DateTime  @default(now())
  completedAt DateTime?

  @@index([fromUserId])
  @@index([toUserId])
  @@index([createdAt])
}

// AI Profile configuration for each user
model AIProfile {
  id            String   @id @default(cuid())
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Model configuration
  llmProvider   String   @default("deepseek")
  llmModel      String   @default("deepseek-chat")
  temperature   Float    @default(0.7)
  maxTokens     Int      @default(2000)
  topP          Float    @default(0.9)
  
  // Prompt configuration
  systemPrompt  String?
  roleTemplate  String   @default("assistant")
  contextPrompts String? // JSON string for scene prompts
  
  // Voice configuration
  voiceTrainings VoiceTraining[]
  activeVoiceId  String?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

// AI Memory system for personalization
model AIMemory {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  type      String   // long_term, short_term
  category  String   // personal, preferences, history
  title     String
  content   String
  tags      String   // Comma-separated tags
  score     Float    @default(1.0) // Weight score for importance
  
  metadata  String?  // JSON string for extra metadata
  expiresAt DateTime? // Expiration for short-term memories
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([userId, type, category])
  @@index([userId, score])
}

// Voice training records
model VoiceTraining {
  id          String   @id @default(cuid())
  userId      String
  profileId   String
  profile     AIProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  
  name        String
  version     String
  status      String   @default("pending") // pending, training, completed, failed
  progress    Int      @default(0)
  
  // TOS storage references
  sampleKeys  String   // JSON array of TOS storage keys
  modelKey    String?  // Trained model key in TOS
  
  sampleCount Int      @default(0)
  duration    Int      @default(0) // Total duration in seconds
  accuracy    Float?   // Similarity score
  
  trainingStartedAt  DateTime?
  trainingCompletedAt DateTime?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}
